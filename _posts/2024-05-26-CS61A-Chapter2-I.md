---
layout: post
title:  "CS61A-Chapter2-I"
date:   2024-05-26 16:38:00 +0000
categories: Note
tags: CS61A 
---

Notes covering [CS61A-2024](https://cs61a.org/) Weeks 5 to 6: Sequences, Containers, Data Abstraction, Trees, and Mutability. 

# 2.1 Introduction

## 2.2.1 Native Data Types

Every value in Python has aÂ *class*Â that determines what type of value it is. Values that share a class also share behaviour. 

Properties of *Native data* types:

- There are expressions that evaluate to values of native types, calledÂ *literals(å­—é¢é‡)*.
- There are built-in functions and operators to manipulate values of native types.

<aside>
ğŸ§€ &nbsp; <strong>Note</strong>
<ol>
  <li>Variableæ˜¯ä¸€ä¸ªå‘½åçš„å­˜å‚¨ä½ç½®ï¼Œå³ä¿å­˜æ•°æ®çš„å®¹å™¨ï¼Œè¿™äº›æ•°æ®åç»­å¯è¢«æ›´æ”¹ã€‚Python å˜é‡ä¸éœ€è¦æ˜¾å¼å£°æ˜ï¼Œåªéœ€è¦ä½¿ç”¨èµ‹å€¼è¯­å¥ã€‚</li>
  <li>Constantæ˜¯ä¸€ä¸ªå‘½åçš„å­˜å‚¨ä½ç½®ï¼Œç”¨äºå­˜å‚¨æ•°æ®å€¼ï¼Œä¸”è¿™äº›å€¼åœ¨ç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸èƒ½æ”¹å˜ï¼Œ é€šå¸¸æ˜¯åœ¨æ¨¡å—ä¸­å£°æ˜å’Œåˆ†é…çš„ã€‚ä¸€èˆ¬é€šè¿‡å‘½åçº¦å®šï¼ˆé€šå¸¸ä½¿ç”¨å…¨å¤§å†™å­—æ¯ï¼‰æ¥è¡¨ç¤ºå˜é‡åº”è¯¥è¢«è§†ä¸ºå¸¸é‡ã€‚</li>
  <li>literalsæ˜¯å€¼çš„ç›´æ¥è¡¨ç¤ºï¼Œæ˜¯å¸¸é‡çš„å…·ä½“å½¢å¼ã€‚å­—é¢é‡å¯ä»¥èµ‹å€¼ç»™å˜é‡æˆ–å¸¸é‡ã€‚</li>
</ol>
</aside>

### Float

The nameÂ **float**Â comes from the way in which real numbers are represented in Python and many other programming languages: a "floating point" representation.Â 

- `int`Â å¯¹è±¡å¯ä»¥ç²¾ç¡®è¡¨ç¤ºæ•´æ•°ï¼Œæ²¡æœ‰ä»»ä½•è¿‘ä¼¼æˆ–å¤§å°é™åˆ¶ã€‚
    - Dividing oneÂ **int**Â by another yields aÂ **float**Â value: a shortened, limited estimate of the actual division of two integers.
- `float`Â å¯¹è±¡å¯ä»¥è¡¨ç¤ºå„ç§åˆ†æ•°ï¼Œä½†å¹¶éæ‰€æœ‰æ•°å­—éƒ½å¯ä»¥ç²¾ç¡®è¡¨ç¤ºï¼Œå¹¶ä¸”æœ‰æœ€å°å’Œæœ€å¤§å€¼ã€‚å› æ­¤ï¼ŒÂ **float**Â å€¼åº”è¢«è§†ä¸ºå¯¹å®é™…å€¼çš„è¿‘ä¼¼ã€‚è¿™äº›è¿‘ä¼¼å€¼åªæœ‰æœ‰é™çš„ç²¾åº¦ã€‚

### Non-numeric types

Values can represent many other types of data, such as sounds, images, locations, web addresses, network connections, and more. A few are represented by native data types, such as theÂ **bool**Â class for valuesÂ **True**Â andÂ **False**.

<aside>
ğŸ§€ &nbsp; Python 3 ä¸­çš„å…­ç§æ ‡å‡†æ•°æ®ç±»å‹ï¼šå­—ç¬¦ä¸²ï¼ˆStringï¼‰ã€æ•°å­—ï¼ˆNumberï¼‰ã€åˆ—è¡¨ï¼ˆListï¼‰ã€å…ƒç»„ï¼ˆTupleï¼‰ã€é›†åˆï¼ˆSetsï¼‰ã€å­—å…¸ï¼ˆDictionaryï¼‰ã€‚

</aside>

# 2.2 Data Abstraction

The use of compound data enables us to increase the modularity of our programs.

The general technique of isolating the parts of a program that deal with how data are represented (constructed)from the parts that deal with how data are manipulated (used) is a powerful design methodology calledÂ *data abstraction*. 

<aside>
âœ‚ï¸ &nbsp; Data abstraction makes programs much easier to design, maintain, and modify.

</aside>

## 2.2.3Â Â Â Abstraction Barriers

æŠ½è±¡å±éšœæ˜¯æŒ‡åœ¨ç¨‹åºè®¾è®¡ä¸­ï¼Œé€šè¿‡åˆ†å±‚çš„æ–¹æ³•å°†ä¸åŒå±‚æ¬¡çš„æŠ½è±¡åˆ†å¼€ï¼Œæ¯ä¸€å±‚åªå…³æ³¨ç‰¹å®šçš„ç»†èŠ‚ï¼Œè€Œä¸éœ€è¦äº†è§£å…¶ä»–å±‚çš„å®ç°ç»†èŠ‚ã€‚

æŠ½è±¡å±éšœæœ‰ä»¥ä¸‹å‡ ä¸ªä¼˜ç‚¹ï¼š

1. **æ¨¡å—åŒ–**ï¼šç¨‹åºè¢«åˆ†æˆè‹¥å¹²æ¨¡å—ï¼Œæ¯ä¸ªæ¨¡å—åªè´Ÿè´£ç‰¹å®šçš„åŠŸèƒ½ã€‚
2. **å¯ç»´æŠ¤æ€§**ï¼šå½“éœ€è¦ä¿®æ”¹ç¨‹åºæ—¶ï¼Œåªéœ€è¦ä¿®æ”¹å¯¹åº”å±‚æ¬¡çš„å®ç°ï¼Œè€Œä¸éœ€è¦ä¿®æ”¹å…¶ä»–éƒ¨åˆ†ã€‚
3. **æ˜“è¯»æ€§**ï¼šä»£ç æ›´æ˜“äºç†è§£ï¼Œå› ä¸ºæ¯ä¸€å±‚æ¬¡åªå…³æ³¨æŸä¸ªç‰¹å®šçš„ç»†èŠ‚ã€‚
4. **çµæ´»æ€§**ï¼šå¯ä»¥æ›´å®¹æ˜“åœ°æ›´æ”¹æˆ–æ›¿æ¢æŸä¸€å±‚æ¬¡çš„å®ç°ï¼Œè€Œä¸ä¼šå½±å“åˆ°æ•´ä¸ªç³»ç»Ÿã€‚

## 2.2.4Â Â Â The Properties of Data

In general, we can express abstract data using a collection of selectors and constructors, together with some behavior conditions.

è€Œåªè¦æ»¡è¶³è¡Œä¸ºæ¡ä»¶ï¼Œselectors å’Œ constructorså°±æ„æˆäº†ä¸€ç§æ•°æ®çš„æœ‰æ•ˆè¡¨ç¤ºã€‚åªè¦Abstraction Barriersçš„è¡Œä¸ºæ²¡æœ‰æ”¹å˜ï¼Œé‚£ä¹ˆæ•°æ®æŠ½è±¡ä»ç„¶æœ‰æ•ˆã€‚

# 2.3 Sequences

A *sequence* is an ordered collection of values. Sequences are not instances of a particular built-in type or abstract data representation, but instead a collection of behaviors that are shared among several different types of data.

- **Length.**Â A sequence has a finite length. An empty sequence has length 0.
- **Element selection.**Â A sequence has an element corresponding to any non-negative integer index less than its length, starting at 0 for the first element.

## 2.3.1 Lists

AÂ *list*Â value is a sequence that can have arbitrary length.Â 

### Several manipulations

The built-inÂ `len`Â function returns the length of a sequence.

```python
>>> digits = [1, 8, 2, 8]
>>> len(digits)
4
```

Lists can be added together and multiplied by integers. For sequences, addition and multiplication do not add or multiply elements, but instead combine and replicate the sequences themselves. 

```python
>>> [2, 7] + digits * 2
[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
```

## 2.3.2Â Â Â Sequence Iteration

å¯ä»¥ç”¨foræˆ–è€…whileè¿›è¡Œéå†ã€‚

AÂ **for**Â statement consists of a single clause with the formï¼š

```python
for <name> in <expression>:
    <suite>
```

AÂ **for**Â statement is executed by the following procedure:

1. Evaluate the headerÂ **expression**, which must yield an iterable value.
2. For each element value in that iterable value, in order:
    - BindÂ **name**Â to that value in the current frame.
    - Execute theÂ **suite**.

This execution procedure refers toÂ *iterable values*. Lists are a type of sequence, and sequences are iterable values.Â 

### Sequence unpacking

A common pattern in programs is to have a sequence of elements that are themselves sequences, but all of a fixed length. 

AÂ `for`Â statement may include multiple names in its header to "unpack" each element sequence into its respective elements.Â 

```python
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
>>> same_count = 0
>>> for x, y in pairs:
        if x == y:
            same_count = same_count + 1
>>> same_count
2
```

### Ranges

AÂ *range*Â is another built-in type of sequence in Python, which represents a range of integers. 

Ranges are created withÂ `range`, which takes two integer arguments: the first number and one beyond the last number in the desired range.

```python
>>> list(range(5, 8))
[5, 6, 7]
```

Ranges commonly appear as the expression in aÂ **for**Â header to specify the number of times that the suite should be executed.

```python
>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

A common convention is to use a single underscore character â€œ_â€ for the name in theÂ **for**Â header if the name is unused in the suite.

## 2.3.3Â Â Â Sequence Processing

### List comprehensions

Many sequence processing operations can be expressed by evaluating a fixed expression for each element in a sequence and collecting the resulting values in a result sequence. 

In Python, a *list comprehension* is an expression that performs such a computation.

```python
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

The general form of a list comprehension is:

```python
[<map expression> for <name> in <sequence expression> if <filter expression>]
```

### Aggregation

Another pattern in sequence processing is to aggregate all values in a sequence into a single value. The built-in functionsÂ **sum**,Â **min**, andÂ **max**Â are all examples of aggregation functions.

### Higher-Order Functions

The common patterns we have observed in sequence processing can be expressed using higher-order functions. (`map`,Â `filter`)

## 2.3.4Â Â Â Sequence Abstraction

### Membership

A value can be tested for membership in a sequence. Python has two operatorsÂ **in**Â andÂ **not in**Â that evaluate toÂ **True**Â orÂ **False**Â depending on whether an element appears in a sequence.

```python
>>> digits
[1, 8, 2, 8]
>>> 2 in digits
True
>>> 1828 not in digits
True
```

### Slicing a List

Sequences contain smaller sequences within them. AÂ *slice*Â of a sequence is any contiguous span of the original sequence, designated by a pair of integers.Â 

```python
>>> digits[0:2]
[1, 8]
>>> digits[1:]
[8, 2, 8]
```

### Adding items to a List

There are four ways to add items to a list.

```python
>>> a_list = a_list + [2.0, 3]
>>> a_list.append(True)  
>>> a_list.extend(['four', 'Î©'])
>>> a_list.insert(0, 'Î©')
```

- TheÂ `extend()`Â method takes a single argument, which is always a list, and adds each of the items of that list toÂ a_list.
- theÂ `append()`Â method takes a single argument, which can be any datatype.
- TheÂ `insert()`Â method inserts a single item into a list. The first argument is the index of the first item in the list that will get bumped out of position.

### Searching for values in a List

- TheÂ `count()`Â method returns the number of occurrences of a specific value in a list.
- TheÂ `in`Â operator always returnsÂ `True`Â orÂ `False`
- If you need to know where in the list a value is, call theÂ `index()`Â method.Â TheÂ `index()`Â method finds theÂ *first*Â occurrence of a value in the list. If the value is not found in the list, theÂ `index()`Â method will raise an exception.

```python
>>> a_list = ['a', 'b', 'new', 'mpilgrim', 'new']
>>> a_list.count('new')      
2
>>> 'new' in a_list         
True
>>> 'c' in a_list
False
>>> a_list.index('mpilgrim')
3
>>> a_list.index('new')       
2
```

### Removing items from a List

- You can use theÂ `del`Â statement to delete a specific item from a list.
- You can also remove an item from a list with theÂ `remove()`Â method. TheÂ `remove()`Â method takes aÂ *value*Â and removes the first occurrence of that value from the list.

```python
>>> del a_list[1]
>>> a_list
['a', 'new', 'mpilgrim', 'new']
>>> a_list.remove('new')
>>> a_list
['a', 'mpilgrim', 'new']
```

Another interesting list method isÂ `pop()`. TheÂ `pop()`Â method is yet another way toÂ remove items form a list, but with a twist.

```python
>>> a_list = ['a', 'b', 'new', 'mpilgrim']
>>> a_list.pop()
'mpilgrim'
>>> a_list
['a', 'b', 'new']
>>> a_list.pop(1)
'b'
>>> a_list
['a', 'new']
>>> a_list.pop()
'new'
>>> a_list.pop()
'a'
>>> a_list.pop()
```

- When called without arguments, theÂ `pop()`Â list method removes the last item in the listÂ *and returns the value it removed*.
- You can pop arbitrary items from a list. Just pass a positional index to theÂ `pop()`Â method.
- CallingÂ `pop()`Â on an empty list raises an exception.

## 2.3.5Â Â Â Strings

The native data type for text in Python is called a *string*, and corresponds to the constructorÂ **str**. 

String literals can express arbitrary text, surrounded by either single or double quotation marks.

```python
>>> 'I am string!'
'I am string!'
```

Strings satisfy the two basic conditions of a sequence that we introduced at the beginning of this section: they have a length and they support element selection.

```python
>>> city = 'Berkeley'
>>> len(city)
8
>>> city[3]
'k'
```

The elements of a string are themselves strings that have only a *single character*. A character is any single letter of the alphabet, punctuation mark, or other symbol.

Like lists, strings can also be combined via addition and multiplication.

```python
>>> 'Berkeley' + ', CA'
'Berkeley, CA'
>>> 'Shabu ' * 2
'Shabu Shabu '
```

### Membership

The behavior of strings diverges from other sequence types in Python.

```python
>>> 'here' in "Where's Waldo?"
True
```

### Multiline literals

Strings aren't limited to a single line. Triple quotes delimit string literals that span multiple lines. We have used this triple quoting extensively already for docstrings.

```python
>>> """The Zen of Python
claims, Readability counts.
Read more: import this."""

'The Zen of Python\nclaims, "Readability counts."\nRead more: import this.'
```

### String coercion

A string can be created from any object in Python by calling theÂ **str**Â constructor function with an object value as its argument. This feature of strings is useful for constructing descriptive strings from objects of various types.

```python
>>> str(2) + ' is an element of ' + str(digits)
'2 is an element of [1, 8, 2, 8]'
```

### Formatting Strings

Python 3 supportsÂ formattingÂ values into strings. Although this can include very complicated expressions, the most basic usage is to insert a value into a string with a single placeholder.

```python
>>> username = 'mark'
>>> password = 'PapayaWhip'
>>> "{0}'s password is {1}".format(username, password)
"mark's password is PapayaWhip"
```

Format specifiers allow you to munge the replacement text in a variety of useful ways, like theÂ `printf()`Â function in C. 

```python
>>> '{0:.1f} {1}'.format(698.24, 'GB')
'698.2 GB'
```

### Other common String methods

TheÂ `splitlines()`Â method takes one multiline string and returns a list of strings, one for each line of the original. 

TheÂ `lower()`Â method converts the entire string to lowercase. (Similarly, theÂ `upper()`Â method converts a string to uppercase.)

The `count()` method counts the number of occurrences of a substring.

```python
>>> s = '''It is important
to read more book'''
>>> s.splitlines()
['It is important',
'to read more book']
>>> print(s.lower())
it is important
to read more book
>>> s.lower().count('o')
5
```

TheÂ `split()`Â string method has one required argument, a delimiter. The method splits a string into a list of strings based on the delimiter.

We can use aÂ list comprehensions to iterate over the entire list and split each string into two strings based on the first equals sign.Â 

Python can turn that list-of-lists into a dictionary simply by passing it to theÂ `dict()`Â function.

```python
>>> query = 'user=pilgrim&database=master&password=PapayaWhip'
>>> a_list = query.split('&')
>>> a_list
['user=pilgrim', 'database=master', 'password=PapayaWhip']
>>> a_list_of_lists = [v.split('=', 1) for v in a_list if '=' in v]
>>> a_list_of_lists
[['user', 'pilgrim'], ['database', 'master'], ['password', 'PapayaWhip']]
>>> a_dict = dict(a_list_of_lists)
>>> a_dict
{'password': 'PapayaWhip', 'user': 'pilgrim', 'database': 'master'}
```

## 2.3.6Â Â Â Trees

Using lists within other lists allows us to create complex structures, known as the *closure property*. This means we can combine data in a way that the result can be combined again. Closure lets us build hierarchical structures, where each part can contain smaller parts.

TheÂ *tree*Â is a fundamental data abstraction that imposes regularity on how hierarchical values are structured and manipulated.

- A tree has a root label and a sequence of branches.
- Each branch of a tree is a tree.
- A tree with no branches is called a leaf.
- Any tree contained within a tree is called a sub-tree of that tree (such as a branch of a branch).
- The root of each sub-tree of a tree is called a node in that tree.

The data abstraction for a tree consists of the constructorÂ **tree**Â and the selectorsÂ **label**Â andÂ **branches**.

```python
>>> def tree(root_label, branches=[]):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root_label] + list(branches)
>>> def label(tree):
        return tree[0]
>>> def branches(tree):
        return tree[1:]
```

<aside>
ğŸ§€ &nbsp; Constructorç”¨äºåˆå§‹åŒ–å¯¹è±¡ï¼Œåœ¨ Python ä¸­æ˜¯é€šè¿‡ `__init__` æ–¹æ³•å®ç°çš„ã€‚

</aside>

<aside>
ğŸ§€ &nbsp; Selectorç”¨äºè®¿é—®å¯¹è±¡å†…éƒ¨æ•°æ®ï¼Œå¯ä»¥æ˜¯ç±»çš„æ–¹æ³•æˆ–ç›´æ¥è®¿é—®å±æ€§ã€‚

</aside>

A tree is well-formed only if it has a root label and all branches are also trees. TheÂ `is_tree`Â function is applied in theÂ treeÂ constructor to verify that all branches are well-formed. 

TheÂ `is_leaf`Â function checks whether or not a tree has branches.

```python
>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True
>>> def is_leaf(tree):
        return not branches(tree)
```

### Construct a Tree

Trees can be constructed by nested expressions.

```python
>>> t = tree(3, [tree(1), tree(2, [tree(1), tree(1)])])
>>> t
[3, [1], [2, [1], [1]]]
```

Tree-recursive functions can be used to construct trees.

```python
>>> def fib_tree(n):
        if n == 0 or n == 1:
            return tree(n)
        else:
            left, right = fib_tree(n-2), fib_tree(n-1)
            fib_n = label(left) + label(right)
            return tree(fib_n, [left, right])
```

### Partition Trees

A *partition tree* forÂ **n**Â using parts up to sizeÂ **m**Â is a *binary tree* that represents the choices taken during computation.Â 

In a non-leaf partition tree:

- the left (index 0) branch contains all ways of partitioning nÂ Â using at least oneÂ m,
- the right (index 1) branch contains partitions using parts up toÂ m-1, and
- the root label isÂ m.

```python
>>> def partition_tree(n, m):
        """Return a partition tree of n using parts of up to m."""
        if n == 0:
            return tree(True)
        elif n < 0 or m == 0:
            return tree(False)
        else:
            left = partition_tree(n-m, m)
            right = partition_tree(n, m-1)
            return tree(m, [left, right])
```

Printing the partitions from a partition tree is another tree-recursive process that traverses the tree, constructing each partition as a list.

```python
>>> def print_parts(tree, partition=[]):
        if is_leaf(tree):
            if label(tree):
                print(' + '.join(partition))
        else:
            left, right = branches(tree)
            m = str(label(tree))
            print_parts(left, partition + [m])
            print_parts(right, partition)
```

## 2.3.7Â Â Â Linked Lists

Â common representation of a sequence constructed from nested pairs is called aÂ *linked list*.

Linked lists have recursive structure: the rest of a linked list is a linked list orÂ **'empty'**.

```python
>>> empty = 'empty'
>>> def is_link(s):
        """s is a linked list if it is empty or a (first, rest) pair."""
        return s == empty or (len(s) == 2 and is_link(s[1]))
        
>>> def link(first, rest):
        """Construct a linked list from its first element and the rest."""
        assert is_link(rest), "rest must be a linked list."
        return [first, rest]
        
>>> def first(s):
        """Return the first element of a linked list s."""
        assert is_link(s), "first only applies to linked lists."
        assert s != empty, "empty linked list has no first element."
        return s[0]
        
>>> def rest(s):
        """Return the rest of the elements of a linked list s."""
        assert is_link(s), "rest only applies to linked lists."
        assert s != empty, "empty linked list has no rest."
        return s[1]
        
>>> def len_link(s):
        """Return the length of linked list s."""
        length = 0
        while s != empty:
            s, length = rest(s), length + 1
        return length
        
>>> def getitem_link(s, i):
        """Return the element at index i of linked list s."""
        while i > 0:
            s, i = rest(s), i - 1
        return first(s)
```

### Recursive manipulation

BothÂ `len_link`Â andÂ `getitem_link` are iterative. They peel away each layer of nested pair until the end of the list (inÂ `len_link`) or the desired element (inÂ `getitem_link`) is reached. We can also implement length and element selection using recursion.

```python
>>> def len_link_recursive(s):
        """Return the length of a linked list s."""
        if s == empty:
            return 0
        return 1 + len_link_recursive(rest(s))
        
>>> def getitem_link_recursive(s, i):
        """Return the element at index i of linked list s."""
        if i == 0:
            return first(s)
        return getitem_link_recursive(rest(s), i - 1)
```

### **Recursive Construction**

Linked lists are particularly useful when constructing sequences incrementally, a situation that arises often in recursive computations.

# 2.4 Mutable Data

## 2.4.1Â Â Â The Object Metaphor

*Objects*Â combine data values with behavior. The logic of how an object interacts with other objects is bundled along with the information that encodes the object's value. 

- Objects haveÂ *attributes*, which are named values that are part of the object.
    
    ```python
    <expression> . <name>
    ```
    
- Objects also haveÂ *methods*, which are function-valued attributes. Metaphorically, we say that the object "knows" how to carry out those methods.

## 2.4.2Â Â Â Sequence Objects

Instances of primitive built-in values such as numbers areÂ *immutable*.The values themselves cannot change over the course of program execution. 

<aside>
ğŸ§€ &nbsp; å¯å˜æ•°æ®ç±»å‹ï¼ˆMutable Data Typesï¼‰ï¼šå¯å˜æ•°æ®ç±»å‹æ˜¯æŒ‡å…¶å€¼å¯ä»¥åœ¨åŸåœ°ä¿®æ”¹ï¼Œè€Œä¸åˆ›å»ºæ–°çš„å¯¹è±¡ã€‚è¿™æ„å‘³ç€å¯ä»¥ç›´æ¥æ”¹å˜å¯¹è±¡çš„å†…å®¹ï¼Œè€Œå…¶å†…å­˜åœ°å€ä¿æŒä¸å˜ â†’ Listã€Dictionaryã€Set ã€(byte array)

</aside>

*Mutable* objects are used to represent values that change over time. 

<aside>
ğŸ§€ &nbsp; ä¸å¯å˜æ•°æ®ç±»å‹ï¼ˆImmutable Data Types):ä¸å¯å˜æ•°æ®ç±»å‹æ˜¯æŒ‡ä¸€æ—¦åˆ›å»ºï¼Œå…¶å€¼å°±ä¸èƒ½æ”¹å˜çš„æ•°æ®ç±»å‹ã€‚ä»»ä½•è¯•å›¾ä¿®æ”¹å…¶å€¼çš„æ“ä½œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯ä¿®æ”¹åŸæœ‰å¯¹è±¡ â†’ Numberã€Stringã€Tuple ã€(bool)

</aside>

### **Tuples**

A *tuple*, an instance of the built-inÂ **tuple**Â type, is an immutable sequence. Tuples are created using a tuple literal that separates element expressions by commas.

## 2.4.3Â Â Â Dictionaries

Dictionaries are Python's built-in data type for storing and manipulating correspondence relationships. A dictionary contains key-value pairs, where both the keys and values are objects. 

<aside>
âœ‚ï¸ &nbsp; The <strong>purpose</strong> of a dictionary is to provide an abstraction for storing and retrieving values that are indexed not by consecutive integers, but by descriptive keys.

</aside>

Strings commonly serve as keys, because strings are our conventional representation for names of things. 

```python
>>> numerals = {'I': 1.0, 'V': 5, 'X': 10}
>>> numerals['X']
10
```

A dictionary can have at most one value for each key. Adding new key-value pairs and changing the existing value for a key can both be achieved with assignment statements.

```python
>>> numerals['I'] = 1
>>> numerals['L'] = 50
>>> numerals
{'I': 1, 'X': 10, 'L': 50, 'V': 5}
```

Notice thatÂ **'L'**Â was not added to the end of the output above. Dictionaries are unordered collections of key-value pairs.

### Restrictions

- A key of a dictionary cannot be or contain a mutable value.
    - é”®å‘Šè¯‰Pythonåœ¨å†…å­˜ä¸­æŸ¥æ‰¾é”®å€¼å¯¹çš„ä½ç½®ï¼Œå¦‚æœé”®å‘ç”Ÿæ”¹å˜ï¼Œé”®å€¼å¯¹çš„ä½ç½®å¯èƒ½ä¼šä¸¢å¤±ã€‚
- There can be at most one value for a given key.
    - å­—å…¸è®¾è®¡ç”¨äºå­˜å‚¨å’Œæ£€ç´¢å€¼ï¼Œå› æ­¤æ¯ä¸ªé”®åªèƒ½æœ‰ä¸€ä¸ªå¯¹åº”å€¼ã€‚æˆ‘ä»¬åªèƒ½æ£€ç´¢é”®å¯¹åº”çš„é‚£ä¸ªå€¼ã€‚

A useful method implemented by dictionaries isÂ **get**, which returns either the value for a key, if the key is present, or a default value.Â 

```python
>>> numerals.get('A', 0)
0
>>> numerals.get('V', 0)
5
```

Dictionaries also have a comprehension syntax analogous to those of lists. A key expression and a value expression are separated by a colon. Evaluating a dictionary comprehension creates a new dictionary object.

```python
>>> {x: x*x for x in range(3,6)}
{3: 9, 4: 16, 5: 25}
```

## 2.4.4Â Â Â Local State

Lists and dictionaries haveÂ *local state*. è¿™é‡ŒæŒ‡å®ƒä»¬å†…éƒ¨åŒ…å«çš„æ•°æ®å¯ä»¥è¢«ä¿®æ”¹ã€‚å‡½æ•°ä¹Ÿå¯ä»¥æœ‰æœ¬åœ°çŠ¶æ€ï¼Œç‰¹åˆ«æ˜¯åœ¨ä½¿ç”¨é—­åŒ…æˆ–å¯¹è±¡çš„æ–¹æ³•æ—¶ã€‚æœ¬åœ°çŠ¶æ€ä½¿å‡½æ•°èƒ½å¤Ÿåœ¨å¤šæ¬¡è°ƒç”¨ä¹‹é—´ä¿æŒä¿¡æ¯å…±äº«ã€‚

åœ¨ Python ä¸­ï¼Œ`nonlocal` å£°æ˜ç”¨äºåœ¨åµŒå¥—å‡½æ•°ä¸­å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œè¯¥å˜é‡æŒ‡å‘æœ€è¿‘çš„å°é—­ä½œç”¨åŸŸï¼ˆè€Œä¸æ˜¯å…¨å±€ä½œç”¨åŸŸï¼‰çš„å˜é‡ã€‚

```python
def outer_function():
    x = 10
    def inner_function():
        nonlocal x
        x = 20
        print("Inner:", x)  # è¾“å‡ºï¼šInner: 20
    inner_function()
    print("Outer:", x)  # è¾“å‡ºï¼šOuter: 20

outer_function()
```

### Cost

An expression that contains only pure function calls isÂ *referentially transparent.* å³åœ¨ç¨‹åºä¸­ä½¿ç”¨éçº¯å‡½æ•°æ—¶å¦‚ä½•å½±å“å¼•ç”¨é€æ˜æ€§å’ŒçŠ¶æ€ç®¡ç†ã€‚è€Œéçº¯å‡½æ•°é€šè¿‡æ”¹å˜å¤–éƒ¨çŠ¶æ€æˆ–ä¾èµ–å¤–éƒ¨çŠ¶æ€ï¼Œè¿åäº†è¿™ä¸€æ€§è´¨ã€‚

å¦‚æœå‡½æ•°ä½¿ç”¨äº†`nonlocal` assignmentï¼Œå®ƒå°±å…è®¸äº†åµŒå¥—å‡½æ•°ä¿®æ”¹å¤–å±‚å‡½æ•°çš„å±€éƒ¨å˜é‡ï¼Œå› æ­¤å¼•å…¥äº†çŠ¶æ€å˜åŒ–ï¼Œè¿™æ˜¯ä½¿å¾—å‡½æ•°ä¸æ˜¯çº¯å‡½æ•°äº†ã€‚å› æ­¤å‡½æ•°å¯èƒ½ä¼šåœ¨ä¸åŒæ—¶é—´è¿”å›ä¸åŒç»“æœï¼Œä»è€Œè¿åäº†Referential Transparencyã€‚

```python
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount > balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(10)
print(wd(3))  # 7
print(wd(3))  # 4
```

### Benefit

é€šè¿‡ `nonlocal` å£°æ˜ï¼Œå‡½æ•°å¯ä»¥ä¿æŒå’Œä¿®æ”¹å…¶å†…éƒ¨çŠ¶æ€ï¼Œä½¿å¾—å‡½æ•°è°ƒç”¨ä¹‹é—´å¯ä»¥å…±äº«å’Œç´¯ç§¯çŠ¶æ€ã€‚è¿™è®©æ¯ä¸ªç”±è¯¥å¤–å±‚å‡½æ•°åˆ›å»ºçš„å®ä¾‹éƒ½èƒ½ç‹¬ç«‹åœ°ç»´æŠ¤è‡ªå·±çš„çŠ¶æ€ï¼ˆå˜é‡å’Œæ•°æ®ï¼‰ï¼Œä¸ä¼šç›¸äº’å¹²æ‰°ã€‚

è€Œå®ƒå¸¦æ¥çš„çŠ¶æ€å˜åŒ–ä½¿å¾—å‡½æ•°å¯ä»¥æ¨¡æ‹Ÿå…·æœ‰å†…éƒ¨çŠ¶æ€çš„å¯¹è±¡ï¼Œä»è€Œå®ç°ç±»ä¼¼äºé¢å‘å¯¹è±¡ç¼–ç¨‹çš„æ•ˆæœã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åˆ›å»ºæ›´å¤æ‚çš„ç¨‹åºæ¨¡å—ï¼Œè®©æ¯ä¸ªæ¨¡å—ç‹¬ç«‹ç®¡ç†è‡ªå·±çš„çŠ¶æ€ï¼Œä»¥æ­¤æå‡ç¨‹åºçš„çµæ´»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

## 2.4.7Â Â Â Implementing Lists and Dictionaries

è¿™éƒ¨åˆ†è®²äº†å®ç°å¯å˜é“¾è¡¨å’Œå­—å…¸çš„å…·ä½“æ–¹æ³•ã€‚å› ä¸ºPython ä¸æä¾›ç›´æ¥å®ç°åˆ—è¡¨çš„æœºåˆ¶ï¼Œä½†é€šè¿‡å‡½æ•°å’Œå±€éƒ¨çŠ¶æ€å¯ä»¥å®ç°ä¸€ä¸ªå¯å˜çš„é“¾è¡¨ã€‚

### Link List

ä¸€ä¸ªå¯å˜é“¾è¡¨å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªå…·æœ‰é“¾è¡¨ä½œä¸ºå±€éƒ¨çŠ¶æ€çš„å‡½æ•°ã€‚å› æ­¤å¯ä»¥ä½¿ç”¨ `nonlocal` å£°æ˜æ¥ç®¡ç†é“¾è¡¨çš„çŠ¶æ€ã€‚

```python
def mutable_link():
    """Return a functional implementation of a mutable linked list."""
    contents = empty

    def dispatch(message, value=None):
        nonlocal contents
        if message == 'len':
            return len_link(contents)
        elif message == 'getitem':
            return getitem_link(contents, value)
        elif message == 'push_first':
            contents = link(value, contents)
        elif message == 'pop_first':
            f = first(contents)
            contents = rest(contents)
            return f
        elif message == 'str':
            return join_link(contents, ", ")
    return dispatch

def to_mutable_link(source):
        """Return a functional list with the same contents as source."""
        s = mutable_link()
        for element in reversed(source):
            s('push_first', element)
        return s
```

```python
>>> s = to_mutable_link(suits)
>>> type(s)
<class 'function'>
>>> print(s('str'))
heart, diamond, spade, club
```

### Dictionary

æˆ‘ä»¬å¯ä»¥åœ¨Â dispatchÂ çš„ä¸»ä½“ä¸­æ·»åŠ é¢å¤–çš„Â elifÂ å­å¥ï¼Œæ¯ä¸ªå­å¥éƒ½æ£€æŸ¥ä¸€ä¸ªæ¶ˆæ¯ï¼ˆä¾‹å¦‚Â 'extend'Â ï¼‰å¹¶ç›´æ¥å¯¹Â contentsÂ åº”ç”¨é€‚å½“çš„æ›´æ”¹ã€‚è¿™ç§æ–¹æ³•å°†å¯¹æ•°æ®å€¼çš„æ‰€æœ‰æ“ä½œé€»è¾‘å°è£…åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œå‡½æ•°æ ¹æ®æ”¶åˆ°çš„â€œæ¶ˆæ¯â€ï¼ˆé€šå¸¸æ˜¯å­—ç¬¦ä¸²ï¼‰æ‰§è¡Œä¸åŒçš„æ“ä½œï¼Œå³*Message passing*ã€‚

In this case, we use a list of key-value pairs to store the contents of the dictionary. Each pair is a two-element list.

```python
def dictionary():
        """Return a functional implementation of a dictionary."""
        records = []
        def getitem(key):
            matches = [r for r in records if r[0] == key]
            if len(matches) == 1:
                key, value = matches[0]
                return value
        def setitem(key, value):
            nonlocal records
            non_matches = [r for r in records if r[0] != key]
            records = non_matches + [[key, value]]
        def dispatch(message, key=None, value=None):
            if message == 'getitem':
                return getitem(key)
            elif message == 'setitem':
                setitem(key, value)
        return dispatch
```

```python
d = dictionary()
d('setitem', 3, 9)
d('setitem', 4, 16)
print(d('getitem', 3))  # 9
print(d('getitem', 4))  # 16
```

## 2.4.9Â Â Â Propagating Constraints

Mutable data allows us to simulate systems with change, but also allows us to build new kinds of abstractions. Expressing programs as constraints is a type ofÂ *declarative programming,* in which a programmer declares the structure of a problem to be solved, but abstracts away the details of exactly how the solution to the problem is computed.

We combine constraints by constructing a network in which constraints are joined by connectors. A connector is an object that "holds" a value and may participate in one or more constraints.